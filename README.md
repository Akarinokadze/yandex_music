# Исследовательский хакатон от Яндекс.Музыка

## Общее описание задачи
Обнаружение треков каверов - важная продуктовая задача, которая может значительно улучшить качество рекомендаций музыкального сервиса и повысить счастье пользователей. Если мы умеем с высокой точностью классифицировать каверы и связывать их между собой, то можно предложить пользователю новые возможности для управления потоком треков. Например:

   * по желанию пользователя можем полностью исключить каверы из рекомендаций;
   * показать все каверы на любимый трек пользователя;
   * контролировать долю каверов в ленте пользователя.

## Цели исследования
В этом хакатоне нам предлагается разработать решение, которое:

   * может классифицировать треки по признаку кавер-некавер;
   * связывать (группировать) каверы и исходный трек;
   * находит исходный трек в цепочке каверов.

## Стратегия
В работе мы исследовали стратегию попарного сравнения треков в датасете с вычислением признаков, в первую очередь, косинусное расстояние между векторными представлениями текстов и названий треков, полученных language-agnostic трансформером.

## Результаты

Всего было исследовано два основных подхода.

**Прямой подход**

Бинарная классификация на данных, полученных объединением исходных файлов, с преобразованием текстов в эмбеддинги и добавлением новых признаков.

Плюсы данного подхода:

  * простота обработки данных
  * возможность "на лету" проверять новые треки

Минусы подхода:

  * не решает задачу поиска ближайших соседей и оригинального трека
  * не очень высокая точность, но он может быть использован для поиска пула кандидатов для работы со второй моделью

**Попарное сравнение треков**

Суть подхода в получении эмбеддингов текстов и названий треков и дальнейшего попарного сравнения всех треков с помощью косинусной близости и других параметров.

Такое решение по данным о песнях сможет собрать для заданного трека пул композиций максимально близких по смыслу, отобрать среди них нимболее раннюю в качестве исходного трека и отсортировать остальные в порядке похожести.

Плюсы данного подхода:

  * высокая точность
  * интуитивное и простое создание списка треков-каверов для заданного
  * лёгкость фильтрации и ранжирования отобранных треков, например, фильтрация каверов определённой временной эпохи

Минусы подхода:

  * каждый раз для нового трека требуется расчёт мер близости со всеми другими треками и или хранение этой информации (что потребует места), или перерасчёт "на лету" (что потребует вычислительных мощностей)
  
Возможные пути преодоления ограничений:

  * для обоих вариантов можно отбирать простой моделью (только по метаданным) пул потенциальных кандидатов на кавер и только для них вычислять меры схожести и сравнивать между собой. Таким образом в случае с хранением данных - у каждого трека будет матрица ограниченного размера с данными о близости с предварительно отобранным сектором. А в случае с расчётом "на лету", будет просто меньшая выборка кандидатов.

В качестве улучшений для данной работы можно предложить переразметить данные, т.к. при выбранной постановке нас интересует не наличие оригинала, а наличие связи между треками.

## Используемый стек

Jupyter Notebook

Python - pandas, numpy, matplotlib, seaborn, re, sklearn, torch, sentence_transformers, catboost
