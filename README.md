# Исследовательский хакатон от Яндекс.Музыка

## Общее описание задачи.
Обнаружение треков каверов - важная продуктовая задача, которая может значительно улучшить качество рекомендаций музыкального сервиса и повысить счастье пользователей. Если мы умеем с высокой точностью классифицировать каверы и связывать их между собой, то можно предложить пользователю новые возможности для управления потоком треков. Например:

   * по желанию пользователя можем полностью исключить каверы из рекомендаций;
   * показать все каверы на любимый трек пользователя;
   * контролировать долю каверов в ленте пользователя.

## Цели исследования:
в этом хакатоне нам предлагается разработать решение, которое:

   * может классифицировать треки по признаку кавер-некавер;
   * связывать (группировать) каверы и исходный трек;
   * находит исходный трек в цепочке каверов.

## Стратегия:
в работе мы исследовали стратегию попарного сравнения треков в датасете с вычислением признаков, в первую очередь, косинусное расстояние между векторными представлениями текстов и названий треков, полученных language-agnostic трансформером.

## Результаты:

В данной работе мы создали решение, которое по данным о песнях сможет собрать для заданного трека пул композиций максимально близких по смыслу, отобрать среди них нимболее раннюю в качестве исходного трека и отсортировать остальные в порядке похожести.

Плюсы данного подхода:

   * высокая точность
   * интуитивное и простое создание списка треков-каверов для заданного
   * лёгкость фильтрации и ранжирования отобранных треков, например, фильтрация каверов определённой временной эпохи

Минусы подхода:

   * каждый раз для нового трека требуется расчёт мер близости со всеми другими треками и или хранение этой информации (что потребует места), или перерасчёт "на лету" (что потребует вычислительных мощностей)

Возможные пути преодоления ограничений:

   * для обоих вариантов можно отбирать простой моделью (только по метаданным) пул потенциальных кандидатов на кавер и только для них вычислять меры схожести и сравнивать между собой. Таким образом в случае с хранением данных - у каждого трека будет матрица ограниченного размера с данными о близости с предварительно отобранным сектором. А в случае с расчётом "на лету", будет просто меньшая выборка кандидатов.

В качестве улучшений для данной работы можно предложить переразметить данные, т.к. при выбранной постановке нас интересует не наличие оригинала, а наличие связи между треками.

## Используемый стек

Jupyter Notebook

Python - pandas, numpy, matplotlib, seaborn, re, sklearn, torch, sentence_transformers, catboost
